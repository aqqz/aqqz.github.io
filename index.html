<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Taozhi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="nav-outer">
    <nav id="main-nav" class="outer">
      <a id="main-nav-toggle" class="nav-icon"></a>
      
        <a class="main-nav-link" href="index.html">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/about">About</a>
      
    </nav>
    <nav id="sub-nav">
      
    </nav>
  </div>
  <div id="header-title" class="inner">
    <h1 id="logo-wrap">
      <a href="index.html" id="logo">Taozhi</a>
    </h1>
    
      <h2 id="subtitle-wrap">
        <a href="index.html" id="subtitle">Taozhi&#39;s Blog</a>
      </h2>
    
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Linux高级命令使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/07/02/Linux%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2022-07-02T08:38:53.000Z" itemprop="datePublished">2022-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/07/02/Linux%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">Linux高级命令使用</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ln(link,-连接文件)">ln(link, 连接文件)</h2>
<ul>
<li>
<p>windows中的快捷方式和指向的目标是两个独立文件</p>
</li>
<li>
<p>Linux中有两种连接文件：</p>
<ul>
<li>软链接（符号链接）等同于Windows里的快捷方式</li>
<li>硬链接 增加源文件的引用计数，删除文件时，引用计数减一，当引用计数为0，源文件才会被真正删除</li>
</ul>
</li>
<li>
<p>创建软链接</p>
</li>
</ul>
<div class="highlight"><pre class="code"><code>ln -s src link-&gt;src
</code></pre></div>
<ul>
<li>创建硬链接</li>
</ul>
<div class="highlight"><pre class="code"><code>ln src link-&gt;src
</code></pre></div>
<ul>
<li>ls -l查看文件类型：
<ul>
<li>‘-’ 表示普通文件</li>
<li>‘d’ 表示文件夹</li>
<li>‘l’ 表示符号连接文件</li>
<li>‘p’ 表示管道文件</li>
<li>‘s’ 表示socket文件</li>
</ul>
</li>
</ul>
<h2 id="man-查询手册">man 查询手册</h2>
<ul>
<li>查询命令</li>
</ul>
<div class="highlight"><pre class="code"><code>man 1 ls
</code></pre></div>
<ul>
<li>查询linux api</li>
</ul>
<div class="highlight"><pre class="code"><code>man 2 mkdir
</code></pre></div>
<ul>
<li>查询C库函数</li>
</ul>
<div class="highlight"><pre class="code"><code>man 3 stoi
</code></pre></div>
<h2 id="vim-高级命令">vim 高级命令</h2>
<ul>
<li>快速换行(命令模式+行号)</li>
</ul>
<div class="highlight"><pre class="code"><code>: <span class="hljs-number">1</span> # 快速跳转到第一行
</code></pre></div>
<ul>
<li>删除连续多行</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-number">3</span>dd # 删除从当前行开始的三行
</code></pre></div>
<ul>
<li>行复制粘贴</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-number">3</span>yy <span class="hljs-meta"># 复制从当前行开始的三行</span>
p <span class="hljs-meta"># 粘贴到下一行</span>
</code></pre></div>
<h2 id="rwx与权限表示">rwx与权限表示</h2>
<p>drwxr-xr-x : 10个字符， 第一个字符表示文件类型。剩下9个分成3组， 表示文件权限。</p>
<ul>
<li>
<p>前三个表示此文件属主对文件的权限</p>
</li>
<li>
<p>中间三个表示此文件属主所在的组对文件的权限</p>
</li>
<li>
<p>后三个表示其他用户对文件的权限</p>
</li>
<li>
<p>‘r’ 代表可读4</p>
</li>
<li>
<p>‘w’ 代表可写2</p>
</li>
<li>
<p>‘x’ 代表可执行1</p>
</li>
<li>
<p>‘-’ 代表空权限0</p>
</li>
</ul>
<h2 id="find-查找文件">find 查找文件</h2>
<p>知道文件名，但是不知道具体路径在哪</p>
<div class="highlight"><pre class="code"><code>find /etc -name <span class="hljs-string">&quot;interfaces&quot;</span>
</code></pre></div>
<h2 id="grep-在文件中查找">grep 在文件中查找</h2>
<p>想查找字符串出现在哪些文件的哪些行</p>
<div class="highlight"><pre class="code"><code>grep -nr <span class="hljs-string">&quot;字符串&quot;</span> *
</code></pre></div>
<h2 id="uname-查看系统信息">uname 查看系统信息</h2>
<div class="highlight"><pre class="code"><code>uname -a
</code></pre></div>
<h2 id="mount/umount-挂载">mount/umount 挂载</h2>
<div class="highlight"><pre class="code"><code>mount -t nfs -o nolock 192.168.1.141:/root/rootfs /mnt
umount /mnt
</code></pre></div>
<h2 id="df/du-磁盘空间相关">df/du 磁盘空间相关</h2>
<div class="highlight"><pre class="code"><code>df -h <span class="hljs-comment"># 显示已挂载的分区列表</span>
du -h <span class="hljs-comment"># 列出文件或文件夹的大小</span>
du -h <span class="hljs-string">&quot;文件名&quot;</span> <span class="hljs-comment"># 以G/M表示展示文件大小</span>
</code></pre></div>
<h2 id="用户管理">用户管理</h2>
<div class="highlight"><pre class="code"><code>useradd username <span class="hljs-comment"># 添加username 用户</span>
userdel username <span class="hljs-comment"># 删除username 用户</span>
passwd username <span class="hljs-comment"># 为username设置密码</span>
</code></pre></div>
<h2 id="权限管理-chmod/chown/chgrp">权限管理 chmod/chown/chgrp</h2>
<p>权限的数字表示法：</p>
<ul>
<li>‘r’   可读    4</li>
<li>‘w’   可写    2</li>
<li>‘x’   可执行  1</li>
<li>‘-’   无权限  0</li>
</ul>
<p>改权限的命令</p>
<div class="highlight"><pre class="code"><code>chmod 755 文件名 <span class="hljs-comment"># 改变文件权限（主权限/组权限/其他用户权限）</span>
chmod +x  文件名 <span class="hljs-comment"># 给文件增加可执行权限</span>
chmod -x  文件名
</code></pre></div>
<p>改用户和组的命令</p>
<div class="highlight"><pre class="code"><code>chown <span class="hljs-comment"># 修改文件的用户</span>
chgrp <span class="hljs-comment"># 修改文件的组</span>
</code></pre></div>
<h2 id="网络配置">网络配置</h2>
<div class="highlight"><pre class="code"><code>ifconfig eth0 192.168.1.13 <span class="hljs-comment"># 设置ip地址</span>
ifconfig eth0 up <span class="hljs-comment"># 启动网卡</span>
ifconfig eth0 down <span class="hljs-comment"># 关闭网卡</span>
ifup eth0
ifdown eth0
ifconfig eth0 192.168.1.13 netmask 255.255.255.0 <span class="hljs-comment"># 同时设置ip和子网掩码</span>
</code></pre></div>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/linux/" rel="tag">linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二叉树的遍历" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" class="article-date">
  <time class="dt-published" datetime="2022-04-22T01:33:18.000Z" itemprop="datePublished">2022-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>刷题的时候遇到关于二叉树的基础题目，发现很多基础知识都遗忘了，赶紧又看了一遍巩固一下。用博客记录一下，以后多看看。</p>
<h2 id="二叉树的定义">二叉树的定义</h2>
<p>二叉树是一种常见的数据结构，其中每个节点，除了根节点以外，都有唯一一个父节点，每个节点都至多有两个孩子节点。</p>
<p>二叉树常用链式存储，在C语言中用结构体定义二叉树节点：</p>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeLinkNode</span> &#123;</span>
    <span class="hljs-keyword">int</span> val;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeLinkNode</span> *<span class="hljs-title">left</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeLinkNode</span> *<span class="hljs-title">right</span>;</span>
    <span class="hljs-built_in">TreeLinkNode</span>(<span class="hljs-keyword">int</span> x) :<span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;
        
    &#125;
&#125;;
</code></pre></div>
<p>定义的最后一行代码类似C++中构造函数的<strong>初始化列表</strong>的用法。可以看到每个二叉树节点都包含一个数据域和两个指向自己类型的指针域，存储了左右孩子节点的地址。</p>
<h2 id="二叉树的构造">二叉树的构造</h2>
<p>首先声明一点，任意序列构造二叉树是无法实现的，必须有一定约束。因为二叉树有两个分支，无法确定将新节点插在那个分支上。对于二叉搜索树和平衡二叉树都是特殊约束的二叉树，即插入元素的位置是确定的。</p>
<p>这里使用层序插入的方法构造二叉树，所谓层序插入，即从一组序列（向量）读取元素，按元素顺序依此插入的二叉树的每一层中，理论上构造出来的是一颗完全二叉树。</p>
<h3 id="难点分析">难点分析</h3>
<p>考虑层序插入的场景，是不断取元素，不断填充每一层的叶子节点的过程，因此在第n+1层插入节点时，只从第n层的一个父节点插入，这个父节点插满了，需要找第n层的其他父节点。</p>
<p>因此：由于要把节点插入到每一层，因此需要保存之前插入到树中节点的指针，<strong>并且一个节点的左右孩子没有插满时，都要持有对该节点的访问权限</strong>，又是顺序读取元素，顺序插入，因此考虑队列的方法保存节点指针。</p>
<h3 id="算法思路">算法思路</h3>
<ol>
<li>插入一个节点，就把这个节点放入队列尾部（push_back）</li>
<li>每次插入节点时，从队列首部<strong>取</strong>一个元素（front）,该元素是树中应该插入且未插满的元素，如果左孩子空，插左边，右孩子空，插右边</li>
<li>插完右边之后，这个节点就插满了，从队列头部<strong>弹出</strong>（pop_front）</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre class="code"><code>
<span class="hljs-comment">/**
 * @brief 层序遍历构建二叉树
 * 
 * @param array 
 * @return TreeLinkNode* 
 */</span>
<span class="hljs-function">TreeLinkNode* <span class="hljs-title">levelOrderConstructTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; array)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    deque&lt;TreeLinkNode *&gt; q;
    <span class="hljs-comment">//保存根节点</span>
    TreeLinkNode * root = (TreeLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TreeLinkNode));
    root-&gt;left=<span class="hljs-literal">NULL</span>;
    root-&gt;right=<span class="hljs-literal">NULL</span>;
    root-&gt;val=array[<span class="hljs-number">0</span>];
    q.<span class="hljs-built_in">push_back</span>(root);

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;array.<span class="hljs-built_in">size</span>();i++)
    &#123;
        <span class="hljs-comment">//构建叶节点</span>
        TreeLinkNode * node = (TreeLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TreeLinkNode));
        node-&gt;left=<span class="hljs-literal">NULL</span>;
        node-&gt;right=<span class="hljs-literal">NULL</span>;
        node-&gt;val=array[i];

        q.<span class="hljs-built_in">push_back</span>(node);
        
        TreeLinkNode* father = q.<span class="hljs-built_in">front</span>();

        <span class="hljs-keyword">if</span>(father-&gt;left==<span class="hljs-literal">NULL</span>)
        &#123;
            father-&gt;left=node;
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            father-&gt;right=node;
            q.<span class="hljs-built_in">pop_front</span>();
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> root;
&#125;

</code></pre></div>
<h2 id="二叉树的遍历">二叉树的遍历</h2>
<p>接下来的内容才是标题相关的内容。但是二叉树要遍历前提是有一颗二叉树。总的来说，二叉树的遍历有两种方式，一种是层序遍历，按每一层的叶节点访问。另一种是先序、中序、后序，按一定顺序访问这个链式存储结构。</p>
<h3 id="先序遍历">先序遍历</h3>
<p>首先介绍先序遍历，先序遍历是在遍历一颗树时，先访问根节点，再遍历左子树，左子树遍历完，遍历右子树，遍历每颗子树时也按照根节点，左子树，右子树的顺序进行访问。</p>
<h4 id="递归实现">递归实现</h4>
<p>从先序遍历的定义可以看出，用递归进行实现非常容易，代码</p>
<div class="highlight"><pre class="code"><code>
<span class="hljs-comment">/**
 * @brief 二叉树的先序遍历
 * 
 * @param root 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraversal</span><span class="hljs-params">(TreeNode *root)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;
    <span class="hljs-keyword">else</span>
    &#123;
        cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
        <span class="hljs-built_in">preOrderTraversal</span>(root-&gt;left);
        <span class="hljs-built_in">preOrderTraversal</span>(root-&gt;right);
    &#125;
&#125;
</code></pre></div>
<p>访问节点用打印实现</p>
<h4 id="非递归实现">非递归实现</h4>
<p>递归程序本质上使用递归栈实现的，因此手动构建栈也可以实现先序遍历。考虑先序遍历的过程，遇到一个节点，直接访问，然后向左子树延伸，直到左子树到头，这时候回到上一个节点，遍历右子树，因此需要一个栈保存节点的右孩子指针。先遇到的后访问，栈顶优先弹出的是最近的未访问过的右子树。</p>
<ul>
<li>程序思路如下：</li>
</ul>
<ol>
<li>遇到一个节点，不空就访问，并且把节点右指针压栈（push）</li>
<li>根节点向左子树延伸，直到节点的左孩子为空</li>
<li>从栈中弹出顶部元素（pop）作为访问节点</li>
</ol>
<ul>
<li>代码实现：</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraversal2</span><span class="hljs-params">(TreeNode *root)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(root ==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">else</span>
    &#123;
        stack&lt;TreeNode*&gt; s;
        
        <span class="hljs-keyword">while</span>(root || !s.<span class="hljs-built_in">empty</span>())
        &#123;
            <span class="hljs-keyword">while</span>(root)
            &#123;
                cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
                s.<span class="hljs-built_in">push</span>(root-&gt;right);
                root = root-&gt;left;          
            &#125;
            
            <span class="hljs-comment">//左边到头</span>
            <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>())
            &#123;
                <span class="hljs-comment">//根节点切到右子树</span>
                root = s.<span class="hljs-built_in">top</span>();
                s.<span class="hljs-built_in">pop</span>()
            &#125;
        &#125;    
    &#125;    
&#125;
</code></pre></div>
<h3 id="中序遍历">中序遍历</h3>
<p>与先序遍历类似，中序访问时，先访问左子树，再访问根节点，再访问右子树。访问每棵子树时也按照左子树、根节点、右子树的顺序进行。</p>
<h4 id="递归实现-1">递归实现</h4>
<p>直接给出代码</p>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraversal</span><span class="hljs-params">(TreeNode* root)</span>
</span>&#123;
    
    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-built_in">InOrderTraversal</span>(root-&gt;left);
        cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
        <span class="hljs-built_in">InOrderTraversal</span>(root-&gt;right);
    &#125;
&#125;
</code></pre></div>
<h4 id="非递归实现-1">非递归实现</h4>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>遇到一个节点，先不访问，因为先要访问该节点的左子树，所以先把这个节点压栈（push），等会在访问</li>
<li>根节点向左子树延伸，直到左边空，沿路的左子树都被压入堆栈</li>
<li>从堆栈弹出栈顶元素（pop）是最近遇到的节点，访问之，然后根节点切换到该节点的右指针，访问右子树</li>
</ol>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraversal</span><span class="hljs-params">(TreeNode* root)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">else</span>
    &#123;
        stack&lt;TreeNode*&gt; s;
        <span class="hljs-keyword">while</span>(root || !s.<span class="hljs-built_in">empty</span>())
        &#123;
            <span class="hljs-keyword">while</span>(root)
            &#123;
                s.<span class="hljs-built_in">push</span>(root);
                root = root-&gt;left;    
            &#125;
            <span class="hljs-comment">//左边到头</span>
            <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>())
            &#123;
                root = s.<span class="hljs-built_in">top</span>();
                s.<span class="hljs-built_in">pop</span>();                
                cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;                
                root = root-&gt;right;
            &#125;            
        &#125;    
    &#125;    
&#125;
</code></pre></div>
<h3 id="后序遍历">后序遍历</h3>
<p>后序遍历子树的访问顺序为，先递归访问左子树，再递归访问右子树，最后访问根节点</p>
<h4 id="递归实现-2">递归实现</h4>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraversal</span><span class="hljs-params">(TreeNode* root)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-built_in">PostOrderTraversal</span>(root-&gt;left);
        <span class="hljs-built_in">PostOrderTraversal</span>(root-&gt;right);
        cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    &#125;    
&#125;
</code></pre></div>
<h4 id="非递归实现-2">非递归实现</h4>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" rel="tag">数据结构, 算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二维数组中的查找" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/" class="article-date">
  <time class="dt-published" datetime="2022-04-18T03:24:51.000Z" itemprop="datePublished">2022-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">二维数组中的查找</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目描述">题目描述</h2>
<p>在一个二维数组array中（每个一维数组的长度相同），每一行从左至右递增，每一列从上至下递增。完成一个函数，输入这样一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>输入：<br>
[[1, 2, 8, 9],<br>
[2, 4, 9, 12],<br>
[4, 7, 10, 13],<br>
[6, 8, 11, 15]]</p>
<p>给定target=7,返回true.</p>
<p>给定target=3,返回false.</p>
<p>数据范围：矩阵长宽满足0&lt;n,m&lt;500,矩阵中的值满足0&lt;val&lt;10^9</p>
<h2 id="解法：二维数组的二分查找">解法：二维数组的二分查找</h2>
<p>思路：这道题是要在二维有序数组中查找元素，在一维有序数组中查找元素常用二分查找提高效率，因此想尝试拓展到二维。二分查找是通过不断缩小查询范围，每次查找使得搜索空间减半从而提高查找效率的。</p>
<p>在一维二分查找中，常采用数组首尾元素当做查找边界，但是这道题不可以这样做。比如如果（begin0,begin1）左上元素当做首节点，（end0, end1）右下当做尾节点，中间元素（mid0, mid1）和target比较大小，从而确定begin、end变量如何调整。但是在这道题中，按主对角线方向，对于任意元素，其上方和左方元素都比自身小，而其右方和下方元素都比自身大，所以比较大小后无法得到确定的调整方向。</p>
<p>但是如果以副对角线方向选择节点，任意一元素，其左方元素比自身小，下方元素比自身大；其上方元素比自身小，右方元素比自身大，因此选定左下或右上元素作为起点，可以通过比较target大小确定行列的收缩（扩张）范围。如果选择右上元素作为起点，如果target&lt;node,列减小，应该向左侧移动；如果target&gt;node,行增加，应该向下方移动。</p>
<h2 id="代码">代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target, vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; array)</span>
</span>&#123;
    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">int</span> shape0 = array.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">if</span> (shape0 == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">int</span> shape1 = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">if</span>( shape1 == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> col = shape1<span class="hljs-number">-1</span>;

    <span class="hljs-keyword">while</span>(row&lt;shape0 &amp;&amp; col&gt;<span class="hljs-number">-1</span>)
    &#123;
        <span class="hljs-keyword">if</span>(target == array[row][col])
            res = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(target &lt; array[row][col])
        &#123;
            row--;
        &#125;
        <span class="hljs-keyword">if</span>(target &gt; array[row][col])
        &#123;
            col++;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;
</code></pre></div>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" rel="tag">算法刷题</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/02/20/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-02-20T04:00:00.000Z" itemprop="datePublished">2022-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/02/20/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a new post">Create a new post</h3>
<div class="highlight"><pre class="code"><code>$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span>
</code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<div class="highlight"><pre class="code"><code>$ hexo server
</code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static files">Generate static files</h3>
<div class="highlight"><pre class="code"><code>$ hexo generate
</code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to remote sites">Deploy to remote sites</h3>
<div class="highlight"><pre class="code"><code>$ hexo deploy
</code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
      </div>
      <footer id="footer">
  
    <aside id="sidebar" class="outer">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2022/07/02/Linux%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">Linux高级命令使用</a>
          </li>
        
          <li>
            <a href="2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历</a>
          </li>
        
          <li>
            <a href="2022/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">二维数组中的查找</a>
          </li>
        
          <li>
            <a href="2022/02/20/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="tags/linux/" style="font-size: 10px;">linux</a> <a href="tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%97%E6%B3%95/" style="font-size: 10px;">数据结构, 算法</a> <a href="tags/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" style="font-size: 10px;">算法刷题</a>
    </div>
  </div>

  
</aside>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 taozhi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="/js/clipboard.min.js"></script>
<script src="/js/jquery-1.4.3.min.js"></script>

<script src="/fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="/js/script.js"></script>








<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });
  });
</script>

  </div>
</body>
</html>