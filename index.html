<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Taozhi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css">
  
<meta name="generator" content="Hexo 6.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="nav-outer">
    <nav id="main-nav" class="outer">
      <a id="main-nav-toggle" class="nav-icon"></a>
      
        <a class="main-nav-link" href="index.html">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/about">About</a>
      
    </nav>
    <nav id="sub-nav">
      
    </nav>
  </div>
  <div id="header-title" class="inner">
    <h1 id="logo-wrap">
      <a href="index.html" id="logo">Taozhi</a>
    </h1>
    
      <h2 id="subtitle-wrap">
        <a href="index.html" id="subtitle">Taozhi&#39;s Blog</a>
      </h2>
    
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-二维dp——最长回文子串求解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/07/20/%E4%BA%8C%E7%BB%B4dp%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E6%B1%82%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2022-07-20T08:05:56.000Z" itemprop="datePublished">2022-07-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/07/20/%E4%BA%8C%E7%BB%B4dp%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E6%B1%82%E8%A7%A3/">二维dp——最长回文子串求解</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目">题目</h2>
<p>给你一个字符串s，找到s中最长的回文子串</p>
<h2 id="思路">思路</h2>
<ul>
<li>
<p>对于一个字符串，如果它的长度为1，那么必定是回文串。</p>
</li>
<li>
<p>考虑一般情况</p>
</li>
</ul>
<p>如果一个字符串是回文串，那么去掉两端的字符一定也是回文串，比如ababa是回文，其中bab也是回文。那么可以设二维dp数组，dp[i][j]表示字符串从第i位到第j位是否构成回文串（i&lt;=j）</p>
<p>那么，我们只需要填充这个二维表格，找到这个二维表格中“相距最远”的两个1（即代表最长的回文子串）</p>
<ul>
<li>考虑如何递推填充二位dp数组</li>
</ul>
<p>首先考虑基本情况，所有回文子串可以看作由长度为1的子串（构成长度为奇数的回文串）和长度为2的子串（构成长度为偶数的回文子串）两种基本情况扩展来。所以有</p>
<div class="highlight"><pre class="code"><code>dp[i][i] = <span class="hljs-number">1</span>; (i&gt;=<span class="hljs-number">0</span> &amp;&amp; i&lt;str.<span class="hljs-built_in">size</span>())
dp[i][i+<span class="hljs-number">1</span>] = (str[i]==str[i+<span class="hljs-number">1</span>]) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>; (i+<span class="hljs-number">1</span> &lt; str.<span class="hljs-built_in">size</span>())
</code></pre></div>
<p>这样就填充了表格的中间和上边一大部分</p>
<table>
<thead>
<tr>
<th></th>
<th>j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td></td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>0</td>
<td>a</td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>此时考虑填充剩下的部分，由于i&lt;=j，所以只需填充上三角部分对应的矩阵即可，并且，我们考虑了基本情况即子串长度为1和长度为2的情况，只需从长度为3考虑，即j起始位置应该是i+2，同时要保证i和j不越界(0&lt;i&lt;=j&lt;str.size())</p>
<ul>
<li>考虑状态转移情况</li>
</ul>
<p>如果str[i]==str[j]，那么从i到j构成的子串是否是回文串由去掉边界两个字符决定，即dp[i][j]==dp[i+1][j-1]，体现在表格上就是dp[i][j]左下角的元素。如果我们自上而下填充这个表格，会出现一个元素左下角元素未计算的情况，因此，考虑对i从下往上遍历，保证左下角元素存在（i从str.size()-2到0遍历）遍历行的同时，j从左向右遍历，填充一行向上，直到填充整个上三角。</p>
<table>
<thead>
<tr>
<th></th>
<th>j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td></td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>0</td>
<td>a</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
<ul>
<li>计算最长回文子串</li>
</ul>
<p>得到二维dp数组后，从中找每行相距最远的两个1即为对应回文子串的边界下标。找最长回文子串的代码，复杂度O（n^2）</p>
<div class="highlight"><pre class="code"><code>string res;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();i++)
&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j&lt;str.<span class="hljs-built_in">size</span>();j++)
    &#123;
        <span class="hljs-keyword">if</span>(dp[i][j]==<span class="hljs-number">1</span> &amp;&amp; j-i+<span class="hljs-number">1</span>&gt;res.<span class="hljs-built_in">size</span>()) 
        &#123;
            res = str.<span class="hljs-built_in">substr</span>(i，j-i+<span class="hljs-number">1</span>);
        &#125;
    &#125;
&#125;
<span class="hljs-keyword">return</span> res;
</code></pre></div>
<h2 id="代码">代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;
    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> s;
    <span class="hljs-keyword">int</span> len = s.<span class="hljs-built_in">size</span>();
    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt;<span class="hljs-built_in">dp</span>(len，vector&lt;<span class="hljs-keyword">int</span>&gt;(len，<span class="hljs-number">0</span>));
    string res;
    <span class="hljs-comment">//初始化边界</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)
    &#123;
        dp[i][i] = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;len &amp;&amp; s[i]==s[i+<span class="hljs-number">1</span>]) dp[i][i+<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = len<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">2</span>;j&lt;len;j++)
            <span class="hljs-keyword">if</span>(s[i]==s[j]) dp[i][j] = dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>];
        
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j&lt;len;j++) 
            <span class="hljs-keyword">if</span>(dp[i][j]==<span class="hljs-number">1</span> &amp;&amp; j-i+<span class="hljs-number">1</span> &gt; res.<span class="hljs-built_in">size</span>()) res = s.<span class="hljs-built_in">substr</span>(i，j-i+<span class="hljs-number">1</span>);
    
    <span class="hljs-keyword">return</span> res;
&#125;
</code></pre></div>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-STL常见容器用法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/07/10/STL%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2022-07-10T11:31:00.000Z" itemprop="datePublished">2022-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/07/10/STL%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/">STL常见容器用法</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="vector">vector</h2>
<p>vector意为向量，可以理解为变长数组</p>
<ol>
<li>vector定义</li>
</ol>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
vector&lt;<span class="hljs-keyword">typename</span>&gt; name;
</code></pre></div>
<p>vector中存放的类型可以是基本数据类型char, int, double, struct，也可以是STL标准容器，例如vector, set, queue。如果typename也是一个STL容器，定义的时候需要在&gt;&gt;之间加空格，因为在C++11之前会被认为是右移运算符。</p>
<div class="highlight"><pre class="code"><code>vector&lt;<span class="hljs-keyword">int</span>&gt; name;
vector&lt;<span class="hljs-keyword">double</span>&gt; name;
vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt; &gt; name; 
</code></pre></div>
<ol start="2">
<li>vector元素的访问</li>
</ol>
<p>(1) 通过下标访问</p>
<p>(2) 通过迭代器访问</p>
<p>迭代器类似指针, 定义</p>
<div class="highlight"><pre class="code"><code>vector&lt;<span class="hljs-keyword">typename</span>&gt;:: iterator it;
</code></pre></div>
<p>通过迭代器访问vector元素</p>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

vector&lt;<span class="hljs-keyword">int</span>&gt; vi;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)
&#123;
    vi.<span class="hljs-built_in">push_back</span>(i);
&#125;

vector&lt;<span class="hljs-keyword">int</span>&gt;:: iterator it = vi.<span class="hljs-built_in">begin</span>();
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;vi.<span class="hljs-built_in">size</span>();i++)
&#123;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, *(it+i))
&#125;
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
</code></pre></div>
<p>begin()函数用于取vi元素的首地址，end()函数用于取尾元素的下一个地址</p>
<p>使用迭代器遍历的第二种方法</p>
<div class="highlight"><pre class="code"><code><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;:: iterator it=vi.<span class="hljs-built_in">begin</span>();it!=vi.<span class="hljs-built_in">end</span>();it++)
&#123;
    cout&lt;&lt;*it&lt;&lt;endl;
&#125;
</code></pre></div>
<ol start="3">
<li>vector常用函数</li>
</ol>
<p>(1) push_back() 向容器末尾添加一个元素</p>
<p>(2) pop_back() 删除容器末尾元素</p>
<p>(3) size() 范围容器内元素个数</p>
<p>(4) clear() 清空容器内元素</p>
<p>(5) insert(it, x) 向vector的任意迭代器it处插入一个元素x</p>
<p>(6) earse()</p>
<ul>
<li>
<p>earse(it) 除迭代器it位置的元素</p>
</li>
<li>
<p>earse(first, last) 删除[first, last)区间内的元素</p>
</li>
</ul>
<h2 id="set">set</h2>
<p>set意为集合，是一个内部自动去重和有序的容器</p>
<ol>
<li>定义</li>
</ol>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

set&lt;<span class="hljs-keyword">typename</span>&gt; name;
</code></pre></div>
<ol start="2">
<li>set元素的访问</li>
</ol>
<p>set只能通过迭代器访问，除了vector和string之外的STL容器都不能用*(it+N)访问</p>
<div class="highlight"><pre class="code"><code>set&lt;<span class="hljs-keyword">int</span>&gt; st;
st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);
st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">5</span>);
st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">2</span>);
st.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>);
set&lt;<span class="hljs-keyword">int</span>&gt;:: iterator it;

<span class="hljs-keyword">for</span>(it=st.<span class="hljs-built_in">begin</span>();it!=st.<span class="hljs-built_in">end</span>();it++)
&#123;
    cout&lt;&lt;*it&lt;&lt;endl; <span class="hljs-comment">//2 3 5自动去重和排序</span>
&#125;
</code></pre></div>
<ol start="3">
<li>常用函数</li>
</ol>
<p>(1) insert(x) 把x插入容器，自动去重和排序，时间复杂度O(logN)</p>
<p>(2) find(value) 返回set中值为value的迭代器</p>
<p>(3) earse</p>
<ul>
<li>
<p>earse(it) 删除迭代器对应的值</p>
</li>
<li>
<p>earse(value) 删除set中的value</p>
</li>
<li>
<p>earse(first, last) 删除[first, last)区间内的元素</p>
</li>
</ul>
<p>(4) size() 返回set内元素的个数</p>
<p>(5) clear() 清空set元素</p>
<h2 id="string">string</h2>
<p>在C语言中，一般使用char str[]存放字符串，但是操作不方便，容易出错，为了编程者方便地对字符串进行操作，C++在STL中封装了string类型</p>
<ol>
<li>string定义</li>
</ol>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

string str; <span class="hljs-comment">//定义，默认是&quot;&quot;</span>
string str = <span class="hljs-string">&quot;abcd&quot;</span> <span class="hljs-comment">//定义并初始化</span>
</code></pre></div>
<ol start="2">
<li>访问string中的内容</li>
</ol>
<p>(1) 通过下标访问</p>
<p>(2) 通过迭代器访问</p>
<div class="highlight"><pre class="code"><code><span class="hljs-keyword">for</span>(string::iterator it = str.<span class="hljs-built_in">begin</span>();it!=str.<span class="hljs-built_in">end</span>();it++)
&#123;
    cout&lt;&lt;*it&lt;&lt;endl;
&#125;
</code></pre></div>
<ol start="3">
<li>常用函数</li>
</ol>
<p>(1) operator += 字符串拼接运算符</p>
<p>(2) compare operator 比较规则是字典序</p>
<p>(3) size()/length() 返回字符串的长度</p>
<p>(4) insert()</p>
<ul>
<li>insert(pos, string) 在pos位置插入字符串string</li>
</ul>
<div class="highlight"><pre class="code"><code>string str = <span class="hljs-string">&quot;abcxyz&quot;</span>, str2 = <span class="hljs-string">&quot;opq&quot;</span>;
str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">3</span>, str2); <span class="hljs-comment">//abcopqxyz</span>
</code></pre></div>
<ul>
<li>insert(it, it2, it3) it为源字符串的待插入位置，it2和it3为待插入字符串的首尾迭代器，表示[it2, it3)插入到it的位置</li>
</ul>
<div class="highlight"><pre class="code"><code>string str = <span class="hljs-string">&quot;abcxyz&quot;</span>, str2 = <span class="hljs-string">&quot;opq&quot;</span>;
str.<span class="hljs-built_in">insert</span>(str.<span class="hljs-built_in">begin</span>()+<span class="hljs-number">3</span>, str2.<span class="hljs-built_in">begin</span>(), str2.<span class="hljs-built_in">end</span>());
</code></pre></div>
<p>(5) earse()</p>
<ul>
<li>
<p>earse(it) 删除单个元素</p>
</li>
<li>
<p>earse(first, last) 删除区间[first, last)内的元素</p>
</li>
</ul>
<p>(6) clear() 清空字符串内元素</p>
<p>(7) substr(pos, len) 返回字符串从pos位置起，长度为len的子串</p>
<div class="highlight"><pre class="code"><code>string str = <span class="hljs-string">&quot;Thank you for your smile.&quot;</span>;
cout&lt;&lt;str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">//Thank</span>
cout&lt;&lt;str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">14</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//your</span>
cout&lt;&lt;str.<span class="hljs-built_in">substr</span>(<span class="hljs-number">19</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">//smile</span>
</code></pre></div>
<p>(8) string::npos 用于作为find函数失配时的返回值</p>
<p>(9) find()</p>
<ul>
<li>
<p>find(str2) 如果str2是当前字符串的字串，返回出现的首位置，否则返回string::npos</p>
</li>
<li>
<p>find(str2, pos) 从当前字符串的pos位开始匹配str2，返回结果同上</p>
</li>
</ul>
<p>(10) replace</p>
<ul>
<li>
<p>replace(pos, len, str2) 把当前字符串从pos位置开始len长度的字串替换为str2</p>
</li>
<li>
<p>replace(it1, it2, str2) 把当前字符串位于迭代器[it1, it2)范围的字串替换为str2</p>
</li>
</ul>
<h2 id="map">map</h2>
<p>map意为映射，可以将任何基本类型映射到任何基本类型，比如将string映射到int，或者将STL容器映射到STL容器</p>
<ol>
<li>map的定义</li>
</ol>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

map&lt;typename1, typename2&gt; mp;
map&lt;string, <span class="hljs-keyword">int</span>&gt; mp2; <span class="hljs-comment">//建字符串到整形的映射</span>
map&lt;set&lt;<span class="hljs-keyword">int</span>&gt;, string&gt; mp3; <span class="hljs-comment">//建立set容器到字符串的映射</span>
</code></pre></div>
<ol start="2">
<li>map内元素的访问</li>
</ol>
<p>(1) 通过下标访问</p>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp;
    mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">20</span>;<span class="hljs-comment">// 建立&#x27;c&#x27; -&gt; 20</span>
    mp[<span class="hljs-string">&#x27;c&#x27;</span>] = <span class="hljs-number">30</span>;<span class="hljs-comment">// 建立&#x27;c&#x27; -&gt; 30 (20被覆盖)</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, mp[<span class="hljs-string">&#x27;c&#x27;</span>]); <span class="hljs-comment">//30</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div>
<p>(2) 通过迭代器访问 通过it-&gt;first访问map的key, 通过it-&gt;second访问map的value</p>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; mp;
    mp[<span class="hljs-string">&#x27;m&#x27;</span>] = <span class="hljs-number">20</span>;
    mp[<span class="hljs-string">&#x27;r&#x27;</span>] = <span class="hljs-number">30</span>;
    mp[<span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-number">40</span>;
    <span class="hljs-keyword">for</span>(map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt;::iterator it=mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++)
    &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c, %d&quot;</span>, it-&gt;first, it-&gt;second);
    &#125;
&#125;
</code></pre></div>
<p>map的key会按从小到大顺序排列，因为其内部也是基于红黑树实现的</p>
<ol start="3">
<li>常用函数</li>
</ol>
<p>(1) find(key) 返回键为key的映射的迭代器</p>
<p>(2) earse()</p>
<ul>
<li>
<p>earse(it) 删除迭代器it对应的键值对</p>
</li>
<li>
<p>earse(key) 删除键为key对应的元素</p>
</li>
<li>
<p>earse(first, last) 删除迭代器区间[first, last)内的键值对</p>
</li>
</ul>
<p>(3) size() 返回map内键值对的数量</p>
<p>(4) clear() 清空map的元素</p>
<ol start="4">
<li>map的使用场景</li>
</ol>
<ul>
<li>
<p>需要建立字符或字符串与整数映射的题目</p>
</li>
<li>
<p>判断大整数或其他数据类型是否存在的题目，可以把map当做布尔数组使用</p>
</li>
</ul>
<p>注：map的键和值是唯一的，如果需要一个键对应多个值，需要用multimap，另外C++11中还增加了unordered_map，用散列替代红黑树，只做映射不做排序，速度更快</p>
<h2 id="queue">queue</h2>
<p>queue意为队列，在STL中是一个先进先出的容器</p>
<ol>
<li>queue定义</li>
</ol>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
queue&lt;<span class="hljs-keyword">typename</span>&gt; q;
</code></pre></div>
<ol start="2">
<li>queue内元素的访问</li>
</ol>
<p>队列只允许元素先进先出，即插入操作发生在队尾，删除操作发生在队头。STL中通过front()访问队头元素, back()访问队尾元素</p>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    queue&lt;<span class="hljs-keyword">int</span>&gt; q;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)
    &#123;
        q.<span class="hljs-built_in">push</span>(i);
    &#125;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d, %d&quot;</span>, q.<span class="hljs-built_in">front</span>(), q.<span class="hljs-built_in">back</span>());
&#125;
</code></pre></div>
<ol start="3">
<li>常用函数</li>
</ol>
<p>(1) push(x)  x入队，插入队尾</p>
<p>(2) front(), back() 访问队头、队尾元素</p>
<p>(3) pop() 队头元素出队</p>
<p>(4) empty() 检测queue是否空，空返回true,不空返回false</p>
<p>(5) size() 返回queue内元素的个数</p>
<ol start="4">
<li>主要用途</li>
</ol>
<p>实现BFS时，可以通过STL提供的queue,避免自己实现队列遇到错误情况，简化代码</p>
<p>注：使用front()和pop()前，必须用empty()判断队列是否空，队列不空才能pop和取元素</p>
<h2 id="priority_queue">priority_queue</h2>
<p>priority_queue意为优先队列，本质就是一个最大堆（默认）底层用堆实现。在优先队列中，队首元素一定是当前优先队列中优先级最高的那一个。</p>
<ol>
<li>定义</li>
</ol>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
priority_queue&lt;<span class="hljs-keyword">typename</span>&gt; name;
</code></pre></div>
<ol start="2">
<li>元素访问</li>
</ol>
<p>通过top()访问堆顶元素，也就是优先级最高的元素</p>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    priority_queue&lt;<span class="hljs-keyword">int</span>&gt; q;
    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);
    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">4</span>);
    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, q.<span class="hljs-built_in">top</span>()); <span class="hljs-comment">//4</span>
&#125;
</code></pre></div>
<ol start="3">
<li>常用函数</li>
</ol>
<p>(1) push(x) x入队</p>
<p>(2) top() 返回堆顶元素</p>
<p>(3) pop() 弹出堆顶元素</p>
<p>(4) empty() 检测队列是否空</p>
<p>(5) size() 返回队列内元素的个数</p>
<ol start="4">
<li>priority_queue优先级设置</li>
</ol>
<p>(1) 基本数据类型优先级设置<br>
此处基本数据类型就是int, double, char等直接可用的数据类型，优先级队列对他们的设计原则是数字大的优先级高</p>
<div class="highlight"><pre class="code"><code>priority_queue&lt;<span class="hljs-keyword">int</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;, less&lt;<span class="hljs-keyword">int</span>&gt; &gt; q;<span class="hljs-comment">//数字越大优先级越高（降序）</span>
priority_queue&lt;<span class="hljs-keyword">double</span>, vector&lt;<span class="hljs-keyword">double</span>&gt;, greater&lt;<span class="hljs-keyword">double</span>&gt; &gt; q2;<span class="hljs-comment">//数字越小优先级越高（升序）</span>
</code></pre></div>
<p>(2) 结构体类型优先级设置</p>
<p>定义表示水果的结构体，包含水果名称和价格两个成员</p>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fruit</span>
&#123;</span>
    string name;
    <span class="hljs-keyword">int</span> price;
&#125;;
</code></pre></div>
<p>希望水果价格高的优先级高，需要重载operator &lt; 运算符</p>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fruit</span>
&#123;</span>
    string name;
    <span class="hljs-keyword">int</span> price;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (fruit f1, fruit f2) &#123;
        <span class="hljs-keyword">return</span> f1.price &lt; f2.price; <span class="hljs-comment">//内部按水果价格排序</span>
    &#125;
&#125;;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    priority_queue&lt;fruit&gt; q;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fruit</span> <span class="hljs-title">f1</span>, <span class="hljs-title">f2</span>, <span class="hljs-title">f3</span>;</span>
    f1.name = <span class="hljs-string">&quot;桃子&quot;</span>;
    f1.price = <span class="hljs-number">3</span>;
    f2.name = <span class="hljs-string">&quot;梨子&quot;</span>;
    f2.price = <span class="hljs-number">4</span>;
    f3.name = <span class="hljs-string">&quot;苹果&quot;</span>;
    f3.price = <span class="hljs-number">1</span>;
    q.<span class="hljs-built_in">push</span>(f1);
    q.<span class="hljs-built_in">push</span>(f2);
    q.<span class="hljs-built_in">push</span>(f3);
    cout&lt;&lt;q.<span class="hljs-built_in">top</span>().name&lt;&lt;q.<span class="hljs-built_in">top</span>().price&lt;&lt;endl; <span class="hljs-comment">//梨子 4</span>
&#125;
</code></pre></div>
<h2 id="stack">stack</h2>
<p>stack意为栈，是STL中一个后进先出的容器，插入和删除都在栈顶操作</p>
<ol>
<li>定义</li>
</ol>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stack&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
stack&lt;<span class="hljs-keyword">typename</span>&gt; s;
</code></pre></div>
<ol start="2">
<li>栈内部元素的访问</li>
</ol>
<p>由于栈本身是一种后进先出的数据结构，在STL中只能通过top()来访问栈顶元素</p>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    stack&lt;<span class="hljs-keyword">int</span>&gt; st;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">5</span>;i++)
    &#123;
        st.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// push顺序 1, 2, 3, 4, 5</span>
    &#125;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, st.<span class="hljs-built_in">top</span>()); <span class="hljs-comment">//5</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div>
<ol start="3">
<li>常用函数</li>
</ol>
<p>(1) push(x) x入栈</p>
<p>(2) top() 取栈顶元素</p>
<p>(3) pop() 弹出栈顶元素</p>
<p>(4) empty() 判断栈是否空</p>
<p>(5) size() 返回栈内元素个数</p>
<ol start="4">
<li>用途</li>
</ol>
<p>stack用于模拟一些递归栈，用空间换取时间，避免递归层数过多导致的超时</p>
<h2 id="pair">pair</h2>
<p>pair可看作内部有两个元素的结构体，且两个元素的类型可指定</p>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pair</span>
&#123;</span>
    typename1 first;
    typename2 second;
&#125;;
</code></pre></div>
<ol>
<li>pair定义</li>
</ol>
<div class="highlight"><pre class="code"><code><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;map&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
pair&lt;typename1, typename2&gt; name;
</code></pre></div>
<p>如果想定义pair同时初始化，只需跟上一个小括号，里面填上两个待初始化的元素</p>
<div class="highlight"><pre class="code"><code><span class="hljs-function">pair&lt;string, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;haha&quot;</span>, <span class="hljs-number">5</span>)</span></span>;
</code></pre></div>
<p>如果想在代码中临时定义pair,两种方法：</p>
<ul>
<li>类型定义写在前面，后面用小括号</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-function">pair&lt;string, <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;haha&quot;</span>, <span class="hljs-number">5</span>)</span></span>;
</code></pre></div>
<ul>
<li>使用自带的make_pair方法</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;haha&quot;</span>, <span class="hljs-number">5</span>);
</code></pre></div>
<ol start="2">
<li>pair中元素的访问</li>
</ol>
<p>pair中只有两个元素：first和second，按结构体方法去访问即可</p>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    pair&lt;string, <span class="hljs-keyword">int</span>&gt; p;
    p.first = <span class="hljs-string">&quot;haha&quot;</span>;
    p.second = <span class="hljs-number">5</span>;
    cout&lt;&lt;p.first&lt;&lt;p.second&lt;&lt;endl;
    p = <span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;xixi&quot;</span>, <span class="hljs-number">55</span>);
    cout&lt;&lt;p.first&lt;&lt;p.second&lt;&lt;endl;
    p = pair&lt;string, <span class="hljs-keyword">int</span>&gt;(<span class="hljs-string">&quot;heihei&quot;</span>, <span class="hljs-number">5</span>);
    cout&lt;&lt;p.first&lt;&lt;p.second&lt;&lt;endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre></div>
<ol start="3">
<li>用途</li>
</ol>
<ul>
<li>
<p>用来代替二元结构体及其构造函数，节省编码时间</p>
</li>
<li>
<p>作为map的键值对插入</p>
</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    map&lt;string, <span class="hljs-keyword">int</span>&gt; mp;
    mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;heihei&quot;</span>, <span class="hljs-number">5</span>));
    mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;haha&quot;</span>, <span class="hljs-number">10</span>));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iterator it = mp.<span class="hljs-built_in">begin</span>();it!=mp.<span class="hljs-built_in">end</span>();it++)
    &#123;
        cout&lt;&lt;it-&gt;first&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl; <span class="hljs-comment">//haha 10 heihei 5</span>
    &#125;
&#125;
</code></pre></div>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Linux高级命令使用" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/07/02/Linux%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="dt-published" datetime="2022-07-02T08:38:53.000Z" itemprop="datePublished">2022-07-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/07/02/Linux%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">Linux高级命令使用</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="ln(link,-连接文件)">ln(link, 连接文件)</h2>
<ul>
<li>
<p>windows中的快捷方式和指向的目标是两个独立文件</p>
</li>
<li>
<p>Linux中有两种连接文件：</p>
<ul>
<li>软链接（符号链接）等同于Windows里的快捷方式</li>
<li>硬链接 增加源文件的引用计数，删除文件时，引用计数减一，当引用计数为0，源文件才会被真正删除</li>
</ul>
</li>
<li>
<p>创建软链接</p>
</li>
</ul>
<div class="highlight"><pre class="code"><code>ln -s src link-&gt;src
</code></pre></div>
<ul>
<li>创建硬链接</li>
</ul>
<div class="highlight"><pre class="code"><code>ln src link-&gt;src
</code></pre></div>
<ul>
<li>ls -l查看文件类型：
<ul>
<li>‘-’ 表示普通文件</li>
<li>‘d’ 表示文件夹</li>
<li>‘l’ 表示符号连接文件</li>
<li>‘p’ 表示管道文件</li>
<li>‘s’ 表示socket文件</li>
</ul>
</li>
</ul>
<h2 id="man-查询手册">man 查询手册</h2>
<ul>
<li>查询命令</li>
</ul>
<div class="highlight"><pre class="code"><code>man 1 ls
</code></pre></div>
<ul>
<li>查询linux api</li>
</ul>
<div class="highlight"><pre class="code"><code>man 2 mkdir
</code></pre></div>
<ul>
<li>查询C库函数</li>
</ul>
<div class="highlight"><pre class="code"><code>man 3 stoi
</code></pre></div>
<h2 id="vim-高级命令">vim 高级命令</h2>
<ul>
<li>快速换行(命令模式+行号)</li>
</ul>
<div class="highlight"><pre class="code"><code>: <span class="hljs-number">1</span> # 快速跳转到第一行
</code></pre></div>
<ul>
<li>删除连续多行</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-number">3</span>dd # 删除从当前行开始的三行
</code></pre></div>
<ul>
<li>行复制粘贴</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-number">3</span>yy <span class="hljs-meta"># 复制从当前行开始的三行</span>
p <span class="hljs-meta"># 粘贴到下一行</span>
</code></pre></div>
<h2 id="rwx与权限表示">rwx与权限表示</h2>
<p>drwxr-xr-x : 10个字符， 第一个字符表示文件类型。剩下9个分成3组， 表示文件权限。</p>
<ul>
<li>
<p>前三个表示此文件属主对文件的权限</p>
</li>
<li>
<p>中间三个表示此文件属主所在的组对文件的权限</p>
</li>
<li>
<p>后三个表示其他用户对文件的权限</p>
</li>
<li>
<p>‘r’ 代表可读4</p>
</li>
<li>
<p>‘w’ 代表可写2</p>
</li>
<li>
<p>‘x’ 代表可执行1</p>
</li>
<li>
<p>‘-’ 代表空权限0</p>
</li>
</ul>
<h2 id="find-查找文件">find 查找文件</h2>
<p>知道文件名，但是不知道具体路径在哪</p>
<div class="highlight"><pre class="code"><code>find /etc -name <span class="hljs-string">&quot;interfaces&quot;</span>
</code></pre></div>
<h2 id="grep-在文件中查找">grep 在文件中查找</h2>
<p>想查找字符串出现在哪些文件的哪些行</p>
<div class="highlight"><pre class="code"><code>grep -nr <span class="hljs-string">&quot;字符串&quot;</span> *
</code></pre></div>
<h2 id="uname-查看系统信息">uname 查看系统信息</h2>
<div class="highlight"><pre class="code"><code>uname -a
</code></pre></div>
<h2 id="mount/umount-挂载">mount/umount 挂载</h2>
<div class="highlight"><pre class="code"><code>mount -t nfs -o nolock 192.168.1.141:/root/rootfs /mnt
umount /mnt
</code></pre></div>
<h2 id="df/du-磁盘空间相关">df/du 磁盘空间相关</h2>
<div class="highlight"><pre class="code"><code>df -h <span class="hljs-comment"># 显示已挂载的分区列表</span>
du -h <span class="hljs-comment"># 列出文件或文件夹的大小</span>
du -h <span class="hljs-string">&quot;文件名&quot;</span> <span class="hljs-comment"># 以G/M表示展示文件大小</span>
</code></pre></div>
<h2 id="用户管理">用户管理</h2>
<div class="highlight"><pre class="code"><code>useradd username <span class="hljs-comment"># 添加username 用户</span>
userdel username <span class="hljs-comment"># 删除username 用户</span>
passwd username <span class="hljs-comment"># 为username设置密码</span>
</code></pre></div>
<h2 id="权限管理-chmod/chown/chgrp">权限管理 chmod/chown/chgrp</h2>
<p>权限的数字表示法：</p>
<ul>
<li>‘r’   可读    4</li>
<li>‘w’   可写    2</li>
<li>‘x’   可执行  1</li>
<li>‘-’   无权限  0</li>
</ul>
<p>改权限的命令</p>
<div class="highlight"><pre class="code"><code>chmod 755 文件名 <span class="hljs-comment"># 改变文件权限（主权限/组权限/其他用户权限）</span>
chmod +x  文件名 <span class="hljs-comment"># 给文件增加可执行权限</span>
chmod -x  文件名
</code></pre></div>
<p>改用户和组的命令</p>
<div class="highlight"><pre class="code"><code>chown <span class="hljs-comment"># 修改文件的用户</span>
chgrp <span class="hljs-comment"># 修改文件的组</span>
</code></pre></div>
<h2 id="网络配置">网络配置</h2>
<div class="highlight"><pre class="code"><code>ifconfig eth0 192.168.1.13 <span class="hljs-comment"># 设置ip地址</span>
ifconfig eth0 up <span class="hljs-comment"># 启动网卡</span>
ifconfig eth0 down <span class="hljs-comment"># 关闭网卡</span>
ifup eth0
ifdown eth0
ifconfig eth0 192.168.1.13 netmask 255.255.255.0 <span class="hljs-comment"># 同时设置ip和子网掩码</span>
</code></pre></div>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二叉树的遍历" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/" class="article-date">
  <time class="dt-published" datetime="2022-04-22T01:33:18.000Z" itemprop="datePublished">2022-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>刷题的时候遇到关于二叉树的基础题目，发现很多基础知识都遗忘了，赶紧又看了一遍巩固一下。用博客记录一下，以后多看看。</p>
<h2 id="二叉树的定义">二叉树的定义</h2>
<p>二叉树是一种常见的数据结构，其中每个节点，除了根节点以外，都有唯一一个父节点，每个节点都至多有两个孩子节点。</p>
<p>二叉树常用链式存储，在C语言中用结构体定义二叉树节点：</p>
<div class="highlight"><pre class="code"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeLinkNode</span> &#123;</span>
    <span class="hljs-keyword">int</span> val;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeLinkNode</span> *<span class="hljs-title">left</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeLinkNode</span> *<span class="hljs-title">right</span>;</span>
    <span class="hljs-built_in">TreeLinkNode</span>(<span class="hljs-keyword">int</span> x) :<span class="hljs-built_in">val</span>(x)， <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>)， <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;
        
    &#125;
&#125;;
</code></pre></div>
<p>定义的最后一行代码类似C++中构造函数的<strong>初始化列表</strong>的用法。可以看到每个二叉树节点都包含一个数据域和两个指向自己类型的指针域，存储了左右孩子节点的地址。</p>
<h2 id="二叉树的构造">二叉树的构造</h2>
<p>首先声明一点，任意序列构造二叉树是无法实现的，必须有一定约束。因为二叉树有两个分支，无法确定将新节点插在那个分支上。对于二叉搜索树和平衡二叉树都是特殊约束的二叉树，即插入元素的位置是确定的。</p>
<p>这里使用层序插入的方法构造二叉树，所谓层序插入，即从一组序列（向量）读取元素，按元素顺序依此插入的二叉树的每一层中，理论上构造出来的是一颗完全二叉树。</p>
<h3 id="难点分析">难点分析</h3>
<p>考虑层序插入的场景，是不断取元素，不断填充每一层的叶子节点的过程，因此在第n+1层插入节点时，只从第n层的一个父节点插入，这个父节点插满了，需要找第n层的其他父节点。</p>
<p>因此：由于要把节点插入到每一层，因此需要保存之前插入到树中节点的指针，<strong>并且一个节点的左右孩子没有插满时，都要持有对该节点的访问权限</strong>，又是顺序读取元素，顺序插入，因此考虑队列的方法保存节点指针。</p>
<h3 id="算法思路">算法思路</h3>
<ol>
<li>插入一个节点，就把这个节点放入队列尾部（push_back）</li>
<li>每次插入节点时，从队列首部<strong>取</strong>一个元素（front），该元素是树中应该插入且未插满的元素，如果左孩子空，插左边，右孩子空，插右边</li>
<li>插完右边之后，这个节点就插满了，从队列头部<strong>弹出</strong>（pop_front）</li>
</ol>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre class="code"><code>
<span class="hljs-comment">/**
 * @brief 层序遍历构建二叉树
 * 
 * @param array 
 * @return TreeLinkNode* 
 */</span>
<span class="hljs-function">TreeLinkNode* <span class="hljs-title">levelOrderConstructTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; array)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(array.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    deque&lt;TreeLinkNode *&gt; q;
    <span class="hljs-comment">//保存根节点</span>
    TreeLinkNode * root = (TreeLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TreeLinkNode));
    root-&gt;left=<span class="hljs-literal">NULL</span>;
    root-&gt;right=<span class="hljs-literal">NULL</span>;
    root-&gt;val=array[<span class="hljs-number">0</span>];
    q.<span class="hljs-built_in">push_back</span>(root);

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i&lt;array.<span class="hljs-built_in">size</span>();i++)
    &#123;
        <span class="hljs-comment">//构建叶节点</span>
        TreeLinkNode * node = (TreeLinkNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(TreeLinkNode));
        node-&gt;left=<span class="hljs-literal">NULL</span>;
        node-&gt;right=<span class="hljs-literal">NULL</span>;
        node-&gt;val=array[i];

        q.<span class="hljs-built_in">push_back</span>(node);
        
        TreeLinkNode* father = q.<span class="hljs-built_in">front</span>();

        <span class="hljs-keyword">if</span>(father-&gt;left==<span class="hljs-literal">NULL</span>)
        &#123;
            father-&gt;left=node;
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            father-&gt;right=node;
            q.<span class="hljs-built_in">pop_front</span>();
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> root;
&#125;

</code></pre></div>
<h2 id="二叉树的遍历">二叉树的遍历</h2>
<p>接下来的内容才是标题相关的内容。但是二叉树要遍历前提是有一颗二叉树。总的来说，二叉树的遍历有两种方式，一种是层序遍历，按每一层的叶节点访问。另一种是先序、中序、后序，按一定顺序访问这个链式存储结构。</p>
<h3 id="先序遍历">先序遍历</h3>
<p>首先介绍先序遍历，先序遍历是在遍历一颗树时，先访问根节点，再遍历左子树，左子树遍历完，遍历右子树，遍历每颗子树时也按照根节点，左子树，右子树的顺序进行访问。</p>
<h4 id="递归实现">递归实现</h4>
<p>从先序遍历的定义可以看出，用递归进行实现非常容易，代码</p>
<div class="highlight"><pre class="code"><code>
<span class="hljs-comment">/**
 * @brief 二叉树的先序遍历
 * 
 * @param root 
 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraversal</span><span class="hljs-params">(TreeNode *root)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;
    <span class="hljs-keyword">else</span>
    &#123;
        cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
        <span class="hljs-built_in">preOrderTraversal</span>(root-&gt;left);
        <span class="hljs-built_in">preOrderTraversal</span>(root-&gt;right);
    &#125;
&#125;
</code></pre></div>
<p>访问节点用打印实现</p>
<h4 id="非递归实现">非递归实现</h4>
<p>递归程序本质上使用递归栈实现的，因此手动构建栈也可以实现先序遍历。考虑先序遍历的过程，遇到一个节点，直接访问，然后向左子树延伸，直到左子树到头，这时候回到上一个节点，遍历右子树，因此需要一个栈保存节点的右孩子指针。先遇到的后访问，栈顶优先弹出的是最近的未访问过的右子树。</p>
<ul>
<li>程序思路如下：</li>
</ul>
<ol>
<li>遇到一个节点，不空就访问，并且把节点右指针压栈（push）</li>
<li>根节点向左子树延伸，直到节点的左孩子为空</li>
<li>从栈中弹出顶部元素（pop）作为访问节点</li>
</ol>
<ul>
<li>代码实现：</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preOrderTraversal2</span><span class="hljs-params">(TreeNode *root)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(root ==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">else</span>
    &#123;
        stack&lt;TreeNode*&gt; s;
        
        <span class="hljs-keyword">while</span>(root || !s.<span class="hljs-built_in">empty</span>())
        &#123;
            <span class="hljs-keyword">while</span>(root)
            &#123;
                cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
                s.<span class="hljs-built_in">push</span>(root-&gt;right);
                root = root-&gt;left;          
            &#125;
            
            <span class="hljs-comment">//左边到头</span>
            <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>())
            &#123;
                <span class="hljs-comment">//根节点切到右子树</span>
                root = s.<span class="hljs-built_in">top</span>();
                s.<span class="hljs-built_in">pop</span>()
            &#125;
        &#125;    
    &#125;    
&#125;
</code></pre></div>
<h3 id="中序遍历">中序遍历</h3>
<p>与先序遍历类似，中序访问时，先访问左子树，再访问根节点，再访问右子树。访问每棵子树时也按照左子树、根节点、右子树的顺序进行。</p>
<h4 id="递归实现-1">递归实现</h4>
<p>直接给出代码</p>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraversal</span><span class="hljs-params">(TreeNode* root)</span>
</span>&#123;
    
    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-built_in">InOrderTraversal</span>(root-&gt;left);
        cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
        <span class="hljs-built_in">InOrderTraversal</span>(root-&gt;right);
    &#125;
&#125;
</code></pre></div>
<h4 id="非递归实现-1">非递归实现</h4>
<ul>
<li>思路：</li>
</ul>
<ol>
<li>遇到一个节点，先不访问，因为先要访问该节点的左子树，所以先把这个节点压栈（push），等会在访问</li>
<li>根节点向左子树延伸，直到左边空，沿路的左子树都被压入堆栈</li>
<li>从堆栈弹出栈顶元素（pop）是最近遇到的节点，访问之，然后根节点切换到该节点的右指针，访问右子树</li>
</ol>
<ul>
<li>代码</li>
</ul>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraversal</span><span class="hljs-params">(TreeNode* root)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">else</span>
    &#123;
        stack&lt;TreeNode*&gt; s;
        <span class="hljs-keyword">while</span>(root || !s.<span class="hljs-built_in">empty</span>())
        &#123;
            <span class="hljs-keyword">while</span>(root)
            &#123;
                s.<span class="hljs-built_in">push</span>(root);
                root = root-&gt;left;    
            &#125;
            <span class="hljs-comment">//左边到头</span>
            <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>())
            &#123;
                root = s.<span class="hljs-built_in">top</span>();
                s.<span class="hljs-built_in">pop</span>();                
                cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;                
                root = root-&gt;right;
            &#125;            
        &#125;    
    &#125;    
&#125;
</code></pre></div>
<h3 id="后序遍历">后序遍历</h3>
<p>后序遍历子树的访问顺序为，先递归访问左子树，再递归访问右子树，最后访问根节点</p>
<h4 id="递归实现-2">递归实现</h4>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraversal</span><span class="hljs-params">(TreeNode* root)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-built_in">PostOrderTraversal</span>(root-&gt;left);
        <span class="hljs-built_in">PostOrderTraversal</span>(root-&gt;right);
        cout&lt;&lt;root-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;
    &#125;    
&#125;
</code></pre></div>
<h4 id="非递归实现-2">非递归实现</h4>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二维数组中的查找" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/" class="article-date">
  <time class="dt-published" datetime="2022-04-18T03:24:51.000Z" itemprop="datePublished">2022-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">二维数组中的查找</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目描述">题目描述</h2>
<p>在一个二维数组array中（每个一维数组的长度相同），每一行从左至右递增，每一列从上至下递增。完成一个函数，输入这样一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>输入：<br>
[[1， 2， 8， 9]，<br>
[2， 4， 9， 12]，<br>
[4， 7， 10， 13]，<br>
[6， 8， 11， 15]]</p>
<p>给定target=7，返回true.</p>
<p>给定target=3，返回false.</p>
<p>数据范围：矩阵长宽满足0&lt;n，m&lt;500，矩阵中的值满足0&lt;val&lt;10^9</p>
<h2 id="解法：二维数组的二分查找">解法：二维数组的二分查找</h2>
<p>思路：这道题是要在二维有序数组中查找元素，在一维有序数组中查找元素常用二分查找提高效率，因此想尝试拓展到二维。二分查找是通过不断缩小查询范围，每次查找使得搜索空间减半从而提高查找效率的。</p>
<p>在一维二分查找中，常采用数组首尾元素当做查找边界，但是这道题不可以这样做。比如如果（begin0，begin1）左上元素当做首节点，（end0， end1）右下当做尾节点，中间元素（mid0， mid1）和target比较大小，从而确定begin、end变量如何调整。但是在这道题中，按主对角线方向，对于任意元素，其上方和左方元素都比自身小，而其右方和下方元素都比自身大，所以比较大小后无法得到确定的调整方向。</p>
<p>但是如果以副对角线方向选择节点，任意一元素，其左方元素比自身小，下方元素比自身大；其上方元素比自身小，右方元素比自身大，因此选定左下或右上元素作为起点，可以通过比较target大小确定行列的收缩（扩张）范围。如果选择右上元素作为起点，如果target&lt;node，列减小，应该向左侧移动；如果target&gt;node，行增加，应该向下方移动。</p>
<h2 id="代码">代码</h2>
<div class="highlight"><pre class="code"><code><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target， vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; array)</span>
</span>&#123;
    <span class="hljs-keyword">bool</span> res = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">int</span> shape0 = array.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">if</span> (shape0 == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">int</span> shape1 = array[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">if</span>( shape1 == <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> col = shape1<span class="hljs-number">-1</span>;

    <span class="hljs-keyword">while</span>(row&lt;shape0 &amp;&amp; col&gt;<span class="hljs-number">-1</span>)
    &#123;
        <span class="hljs-keyword">if</span>(target == array[row][col])
            res = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span>(target &lt; array[row][col])
        &#123;
            row--;
        &#125;
        <span class="hljs-keyword">if</span>(target &gt; array[row][col])
        &#123;
            col++;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> res;
&#125;
</code></pre></div>

      
    </div>
    <footer class="article-footer">
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="tags/%E4%BA%8C%E5%88%86/" rel="tag">二分</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="2022/02/20/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-02-20T04:00:00.000Z" itemprop="datePublished">2022-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="2022/02/20/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a new post">Create a new post</h3>
<div class="highlight"><pre class="code"><code>$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span>
</code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<div class="highlight"><pre class="code"><code>$ hexo server
</code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static files">Generate static files</h3>
<div class="highlight"><pre class="code"><code>$ hexo generate
</code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to remote sites">Deploy to remote sites</h3>
<div class="highlight"><pre class="code"><code>$ hexo deploy
</code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
      </div>
      <footer id="footer">
  
    <aside id="sidebar" class="outer">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="2022/07/20/%E4%BA%8C%E7%BB%B4dp%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%E6%B1%82%E8%A7%A3/">二维dp——最长回文子串求解</a>
          </li>
        
          <li>
            <a href="2022/07/10/STL%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/">STL常见容器用法</a>
          </li>
        
          <li>
            <a href="2022/07/02/Linux%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/">Linux高级命令使用</a>
          </li>
        
          <li>
            <a href="2022/04/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/">二叉树的遍历</a>
          </li>
        
          <li>
            <a href="2022/04/18/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/">二维数组中的查找</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="tags/C/" style="font-size: 10px;">C++</a> <a href="tags/Linux/" style="font-size: 10px;">Linux</a> <a href="tags/%E4%BA%8C%E5%88%86/" style="font-size: 10px;">二分</a> <a href="tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 10px;">动态规划</a> <a href="tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a>
    </div>
  </div>

  
</aside>
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 taozhi<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a><br>
      
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="/js/clipboard.min.js"></script>
<script src="/js/jquery-1.4.3.min.js"></script>

<script src="/fancybox/jquery.fancybox-1.3.4.pack.js"></script>


<script src="/js/script.js"></script>








<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
        {left: '\\(', right: '\\)', display: false},
        {left: '\\[', right: '\\]', display: true}
      ],
      throwOnError : false
    });
  });
</script>

  </div>
</body>
</html>